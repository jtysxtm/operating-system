# lab2

对实验报告的要求：

- 基于markdown格式来完成，以文本方式为主
- 填写各个基本练习中要求完成的报告内容
- 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别
- 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
- 列出你认为OS原理中很重要，但在实验中没有对应上的知识点

## EX1：理解first-fit 连续物理内存分配算法（思考题）

<!--first-fit 连续物理内存分配算法作为物理内存分配一个很基础的方法，需要同学们理解它的实现过程。请大家仔细阅读实验手册的教程并结合`kern/mm/default_pmm.c`中的相关代码，认真分析default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数，并描述程序在进行物理内存分配的过程以及各个函数的作用。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
- 你的first fit算法是否有进一步的改进空间？-->

### 物理内存分配过程及相关函数

实现过程应该包括以下步骤：

1. 初始化物理内存管理器，设置 free_list 和 nr_free 。

   - default_init
     - 物理内存管理器的初始化函数。用于初始化空闲内存块列表 free_list 并将空闲内存块数量 nr_free 设置为0。
     - 这个函数在系统启动时调用，一次性初始化物理内存管理器。
2. 在系统启动时，通过调用 default_init_memmap 函数初始化可用的物理页面。

   - default_init_memmap
     - 用于初始化内存映射。在系统启动时，内核需要知道哪些物理页面是可用的，default_init_memmap函数被用于初始化这些可用页面。
     - 遍历一个内存块中的每一页，初始化每一页的属性，包括标志 flags 和属性 property；然后将引用计数 ref 设置为0，并将这些页面添加到 free_list 列表中，以表示它们是可用的；更新 nr_free 变量，表示可用页面的总数量。
3. 在进程或内核代码中，使用 default_alloc_pages 函数来分配物理页面，并使用  default_free_pages 函数来释放页面。

   - default_alloc_pages函数

     - 用于分配指定数量的物理页面，实现了第一适应内存分配算法。
     - 遍历 free_list 列表，查找第一个满足需求的空闲块，即可用页面数量大于或等于请求的数量 n。如果找到满足条件的块，分配其中的页面，并将剩余的页面添加回 free_list 列表。如果没有找到满足条件的块，返回NULL。
   - default_free_pages函数

     - 用于释放一组连续的物理页面。
     - 将这些页面添加回 free_list 列表，并尝试合并相邻的空闲块，以最大程度地减少碎片化；更新 nr_free 变量以反映可用页面的数量。
4. 定期调用 default_check 函数来检查物理内存管理器的正确性，以确保它正常工作。

   - default_nr_free_pages函数

     - 用于查询可用页面的数量。
     - 返回 nr_free 变量的值，表示当前系统中可用的物理页面数量。
   - default_check函数

     - 用于检查物理内存管理器的正确性。
     - 执行一系列内存分配和释放操作，并检查各个步骤的结果是否符合预期。这有助于确保物理内存管理器的正确性和稳定性。

### 改进空间

- 碎片化问题

  - 第一适应算法可能导致外部碎片的积累，因为它不够智能，只是找到第一个满足需求的块。
  - 一个可能的改进是使用更高级的分配策略，如Best-Fit、Next-Fit、伙伴系统等，这些算法尝试选择尺寸更接近请求的块，从而减少碎片化。
- 开销

  - 每次都是从低址部分查找，使得查找空闲分区的开销增大；每次查询第一块符合条件的空闲内存块时，最坏情况需要找遍整个链表，时间复杂度是O（N）。
  - 尝试使用平衡二叉树等结构维护空闲块，其中按照中序遍历得到的空闲块序列的物理地址恰好按照从小到大排序，每个二叉树节点上维护该节点为根的子树上的最大的空闲块的大小。使用二分查找查找到物理地址最小的能够满足条件的空闲地址块。

## EX2：实现 Best-Fit 连续物理内存分配算法（需要编程）

<!--在完成练习一后，参考kern/mm/default_pmm.c对First Fit算法的实现，编程实现Best Fit页面分配算法，算法的时空复杂度不做要求，能通过测试即可。
请在实验报告中简要说明你的设计实现过程，阐述代码是如何对物理内存进行分配和释放，并回答如下问题：
- 你的 Best-Fit 算法是否有进一步的改进空间？-->

### 物理内存分配过程及相关函数

实现过程应该包括以下步骤：

1. 初始化物理内存管理器，设置 free_list 和 nr_free 。

   - best_fit_init
     - 物理内存管理器的初始化函数。用于初始化空闲内存块列表 free_list 并将空闲内存块数量 nr_free 设置为0。
     - 这个函数在系统启动时调用，一次性初始化物理内存管理器。
2. 在系统启动时，通过调用 best_fit_init_memmap 函数初始化可用的物理页面。

   - best_fit_init_memmap
     - 用于初始化内存映射。在系统启动时，内核需要知道哪些物理页面是可用的，default_init_memmap函数被用于初始化这些可用页面。
     - 遍历一个内存块中的每一页，初始化每一页的属性，包括标志 flags 和属性 property；然后将引用计数 ref 设置为0，并将这些页面添加到 free_list 列表中，以表示它们是可用的；更新 nr_free 变量，表示可用页面的总数量。
3. 在进程或内核代码中，使用 best_fit_alloc_pages 函数来分配物理页面，并使用  best_fit_free_pages 函数来释放页面。

   - best_fit_alloc_pages函数

     - 用于分配指定数量的物理页面，实现了第一适应内存分配算法。
     - 遍历 free_list 列表，查找满足需求的空闲页框。如果找到满足需求的页面，记录该页面以及当前找到的最小连续空闲页框数量。最终获得满足需求且连续空闲页数量最少的块，分配其中的页面，并将剩余的页面添加回 free_list 列表。如果没有找到满足条件的块，返回NULL。
   - best_fit_free_pages函数

     - 用于释放一组连续的物理页面。
     - 将这些页面添加回 free_list 列表，并尝试合并相邻的空闲块，以最大程度地减少碎片化；更新 nr_free 变量以反映可用页面的数量。
4. 定期调用 best_fit_check 函数来检查物理内存管理器的正确性，以确保它正常工作。

   - best_fit_nr_free_pages函数

     - 用于查询可用页面的数量。
     - 返回 nr_free 变量的值，表示当前系统中可用的物理页面数量。
   - best_fit_check函数

     - 用于检查物理内存管理器的正确性。
     - 执行一系列内存分配和释放操作，并检查各个步骤的结果是否符合预期。这有助于确保物理内存管理器的正确性和稳定性。

### 改进空间

- 开销
  - 未改变维护空闲块的数据结构，每次仍然从低址部分查找，使得查找空闲分区的开销增大；每次查询第一块符合条件的空闲内存块时，最坏情况需要找遍整个链表，时间复杂度是O（N）。
  - 尝试使用平衡二叉树等结构维护空闲块，其中按照中序遍历得到的空闲块序列的物理地址恰好按照从小到大排序，每个二叉树节点上维护该节点为根的子树上的最大的空闲块的大小。使用二分查找查找到物理地址最小的能够满足条件的空闲地址块。

## 扩展练习Challenge：buddy system（伙伴系统）分配算法（需要编程）

Buddy System算法把系统中的可用存储空间划分为存储块(Block)来进行管理, 每个存储块的大小必须是2的n次幂(Pow(2, n)), 即1, 2, 4, 8, 16, 32, 64, 128...

- 参考[伙伴分配器的一个极简实现](http://coolshell.cn/articles/10427.html)， 在ucore中实现buddy system分配算法，要求有比较充分的测试用例说明实现的正确性，需要有设计文档。

### 设计思路

对于这个算法，我们维护一个空闲链表数组，其中第n项指向管理大小为$2^n$页面的块的空闲链表头，这些链表依次存储着当前空闲的对应大小的内存块。

在初始化时，我们从pmm.c的 `page_init()`中添加输出，观察到初始可用的物理内存页为31929，略微少于$2^{15}$，简化设计，在初始化空闲块时，我们只使用$2^{14}=16384$个内存页，在实际处理中，可以将之后的空间划分为较小的内存块，也放入到空闲链表中。

本次实现中，仅对内存块基本的分配、释放做了设计，涉及到更复杂的操作，例如对一个分配的块仅释放其中更小幂级的空间、在释放块时声明的大小溢出到下一个块时，需要对架构进行更好的修改，受限于时间和能力没有做到适配。

### 物理内存分配过程及相关函数

1. 定义了数个函数用于辅助
   * IS_POWER_OF_2
     * 使用与运算来快速检测传入的数是否为2的次幂
   * GET_POWER_OF_2
     * 使用位移运算来得到传入的数相对于2的幂次，向下取整
   * GET_BUDDY
     * 在pmm.c中定义一个fppn，在 `page_init()`中使用 `fppn=pa2page(mem_begin)-pages+nbase;`来获得可用的第一个内存页的物理页号
     * 该函数返回一个Page结构体指针，指向传入的Page的伙伴块
   * SHOW_BUDDY_ARRAY
     * 打印函数，用于输出空闲链表数组的存储情况以及指向的链表上的成员的页面大小
2. 初始化物理内存管理器 `buddy_init`
   * 初始化空闲链表数组中的每一个链表，将幂次 `order`设置为0，空闲空间 `nr_free`设置为0
3. 初始化可用的内存页面 `buddy_init_memmap`
   * 接受传入的空闲块的大小，向下取整为2的幂，得到幂次，初始化从开始到偏移量为取整后的数这个范围内的页面，设置 `flags`和 `property`为0，这个设计中，页的property属性被用来保存该页开始的块的大小，用2的幂次表示。设置ref位为0，表示无引用
   * 将这个初始化后的物理页块加入到空闲链表数组对应的空闲链表中，设置整个块的property（通过设置该块第一个页的property实现）。
4. 分配和释放内存块
   * `buddy_alloc_pages`用于分配指定大小的内存块
     * 对指定的大小向上取整为2的次幂存入n，将幂次存入order
     * 发现对应order的空闲链表上有空闲块，直接进行分配，将该块从链表上断开，设置property位，并更新空闲空间 `nr_free`的大小
     * 否则从第一个比n大的、存在于空闲链表上的空闲块开始进行分割，更新分割后的块的 `property`，将原块从链表上断开，在对应更小一级块的空闲链表上连接分割后的块。回到上一步，判断是否有所需大小的空闲块
   * `buddy_free_pages`用于释放内存块
     * 更新空闲空间 `nr_free`的大小，获取该内存块的伙伴块，将释放的块连接到对应的空闲链表上
     * 当伙伴块没有被使用且内存块不是最大的那一级时进行循环
       * 如果该内存块是右块（在分割时属于较高地址的那一个），则和伙伴块互换位置
       * 断开该内存块以及伙伴块原本在空闲链表上的连接，更新左块（该内存块）的 `property`为原值+1，并将其连接到更大一级的空闲链表上，接着找到这个大小的块的伙伴块，循环。
5. 调用 `basic_check`检查算法设计是否正确

## 扩展练习Challenge：任意大小的内存单元slub分配算法（需要编程）

slub算法，实现两层架构的高效内存单元分配，第一层是基于页大小的内存分配，第二层是在第一层基础上实现基于任意大小的内存分配。可简化实现，能够体现其主体思想即可。

- 参考[linux的slub分配算法/](http://www.ibm.com/developerworks/cn/linux/l-cn-slub/)，在ucore中实现slub分配算法。要求有比较充分的测试用例说明实现的正确性，需要有设计文档。

## 扩展练习Challenge：硬件的可用物理内存范围的获取方法（思考题）

如果 OS 无法提前知道当前硬件的可用物理内存范围，请问你有何办法让 OS 获取可用物理内存范围？

我们查阅资料，发现Linux提供了一种特殊的BIOS中断 `0x15`，有三个子功能，其中子功能号 `0XE801`对应能够检测低15MB和16MB~4GB的内存空间中的内存大小，`0XE820`对应能够遍历主机上全部内存。在开机自检时，BIOS已经能够通过总线地址找到所有的可能内存，可以仿照这个模式在bootloader中实模式调用BIOS中断，探测可用的物理内存范围。

> Challenges是选做，完成Challenge的同学可单独提交Challenge。完成得好的同学可获得最终考试成绩的加分。
